<!doctype html>
<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

    <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
    <script src="../../web-component-tester/browser.js"></script>

    <!-- Step 1: import the element to test -->
    <link rel="import" href="../plotly-plot.html">
  </head>
  <body>
    <test-fixture id="plotly-plot-fixture-hardcoded">
      <template>
        <plotly-plot id="hard-coded-plot"
          data='[
            {
              "x": [1, 2, 3, 4],
              "y": [10, 15, 13, 17],
              "mode": "markers",
              "type": "scatter"
            },
            {
              "x": [2, 3, 4, 5],
              "y": [16, 5, 11, 9],
              "mode": "lines",
              "type": "scatter"
            },
            {
              "x": [1, 2, 3, 4],
              "y": [12, 9, 15, 12],
              "mode": "lines+markers",
              "type": "scatter"
            }
          ]'
          layout='
            {
              "title":"Line and Scatter Plot",
              "height": 400,
              "width": 480
            }
          '
        >
        </plotly-plot>
      </template>
    </test-fixture>

    <test-fixture id="plotly-plot-fixture-empty">
      <template>
        <plotly-plot id="empty-plot"></plotly-plot>
      </template>
    </test-fixture>

    <script>
      describe('<plotly-plot>', function () {
        var hardcodedPlot;
        var emptyPlot;
        var sandbox;

        beforeEach(function () {
          hardcodedPlot = fixture('plotly-plot-fixture-hardcoded');
          emptyPlot = fixture('plotly-plot-fixture-empty');
          sandbox = sinon.sandbox.create();
        });

        afterEach(function () {
          sandbox.restore();
        });


        describe('#redraw', function () {
          it('should not throw an error', function () {
            _([hardcodedPlot, emptyPlot]).forEach(function (polymerPlot) {
              expect(polymerPlot.redraw.bind(hardcodedPlot)).to.not.throw();
            });
          });

          it('should update the data idempotently', function () {
            _([hardcodedPlot, emptyPlot]).forEach(function (polymerPlot) {
              var values = [4, 11, 23, 14];
              polymerPlot.set('data.0.x', values);
              expect(polymerPlot.$.plot.data[0].x).to.deep.equal(values);
              polymerPlot.redraw()
              expect(polymerPlot.$.plot.data[0].x).to.deep.equal(values);
            });
          });

          it('should redraw on data update', function () {
            _([hardcodedPlot, emptyPlot]).forEach(function (polymerPlot) {
              var values = [4, 11, 23, 14];
              var redraw = sandbox.spy(polymerPlot, 'redraw');
              polymerPlot.set('data.0.x', values);
              expect(redraw.called).to.be.ok;
            });
          });

          it('should redraw on nested layout update', function () {
            _([hardcodedPlot, emptyPlot]).forEach(function (polymerPlot) {
              var redraw = sandbox.spy(polymerPlot, 'redraw');
              polymerPlot.set('layout.title', 'New title');
              expect(redraw.called).to.be.ok;
            });
          });

          it('should redraw on nested config update', function () {
            _([hardcodedPlot, emptyPlot]).forEach(function (polymerPlot) {
              var redraw = sandbox.spy(polymerPlot, 'redraw');
              polymerPlot.set('config.showLink', false);
              expect(redraw.called).to.be.ok;
            });
          });

          it('should not redraw in manual mode', function () {
            _([hardcodedPlot, emptyPlot]).forEach(function (polymerPlot) {
              var redraw;
              var values = [4, 11, 23, 14];
              polymerPlot.manual = true;
              redraw = sandbox.spy(polymerPlot, 'redraw');

              polymerPlot.set('data.0.x', values);
              expect(redraw.called).to.not.be.ok;

              polymerPlot.set('layout.title', 'New title');
              expect(redraw.called).to.not.be.ok;

              polymerPlot.set('config.showLink', false);
              expect(redraw.called).to.be.ok;
            });
          });
        });

        describe('#restyle', function () {
          it('should update all traces by default', function () {
            return Promise.all([
              _([hardcodedPlot, emptyPlot]).map(function (polymerPlot) {
                return polymerPlot.restyle({mode: 'lines'})
                  .then(function (resolvedPolymerPlot) {
                    _(resolvedPolymerPlot).data.forEach(function (trace) {
                      expect(trace.mode).to.equal('lines');
                    });
                  });
              })
            ]);
          });

          it('should update specific traces by index', function () {
            return hardcodedPlot.restyle({mode: 'lines'}, 0).then(function (polymerPlot) {
              expect(polymerPlot.data[0].mode).to.equal('lines');
              expect(polymerPlot.data[2].mode).to.not.equal('lines');
            });
          });

          it('should update specific traces by index list', function () {
            var traceIndices = [0, 2];

            return Promise.all([
              hardcodedPlot.restyle({mode: 'lines'}, traceIndices),
              hardcodedPlot.restyle({mode: 'markers'}, 1),
            ]).then(function (polymerPlots) {
              // Both elements of polymerPlots are the same element: hardcodedPlot

              _(traceIndices).forEach(function (traceIndex) {
                expect(polymerPlots[0].data[traceIndex].mode).to.equal('lines');
              });
              expect(polymerPlots[0].data[1].mode).to.equal('markers');
            });
          });
        });

        describe('#relayout', function () {
          it('should update the layout property', function () {
            var newTitle = 'Some other new title';
            return Promise.all([
              _([hardcodedPlot, emptyPlot]).map(function (polymerPlot) {
                return polymerPlot.relayout({title: newTitle}).then(function (resolvedPolymerPlot) {
                  expect(resolvedPolymerPlot.layout.title).to.equal(newTitle);
                });
              })
            ]);
          });
        });

        describe('#addTraces', function () {
          var newTrace = {
            x: [1, 2, 3, 4],
            y: [22, 9, 5, 11],
            mode: 'lines+markers',
            type: 'scatter',
          };

          it('should add individual traces to the end by default', function () {
            return Promise.all([
              _([hardcodedPlot, emptyPlot]).map(function (polymerPlot) {
                return polymerPlot.addTraces(newTrace).then(function (resolvedPolymerPlot) {
                  var data = resolvedPolymerPlot.data;
                  expect(data[data.length - 1]).to.deep.equal(newTrace);
                });
              })
            ]);
          });

          it('should add individual traces by index', function () {
            return Promise.all([
              _([hardcodedPlot, emptyPlot]).map(function (polymerPlot) {

                return polymerPlot.addTraces(newTrace, 0).then(function (resolvedPolymerPlot) {
                  var data = resolvedPolymerPlot.data;
                  var oldHeadTrace = data[0];
                  expect(data[0]).to.deep.equal(newTrace);
                  expect(data[1]).to.deep.equal(oldHeadTrace);
                });
              })
            ]);
          });

          it('should add lists of traces by index', function () {
            return Promise.all([
              _([hardcodedPlot, emptyPlot]).map(function (polymerPlot) {
                var addTraceIndices = [0, 1];
                var newTraces = [newTrace, newTrace];

                return polymerPlot.addTraces(newTraces, addTraceIndices).then(function (resolvedPolymerPlot) {
                  _(addTraceIndices).forEach(function (traceIndex, iterationIndex) {
                    expect(resolvedPolymerPlot.data[traceIndex]).to.deep.equal(newTraces[iterationIndex]);
                  });
                });
              })
            ]);
          });

          it('should call low-level redraw', function () {
            return Promise.all([
              _([hardcodedPlot, emptyPlot]).map(function (polymerPlot) {
                var redraw = sandbox.spy(Plotly, 'redraw');

                return polymerPlot.addTraces(newTrace).then(function (resolvedPolymerPlot) {
                  expect(redraw.withArgs(resolvedPolymerPlot.$.plot).calledOnce).to.be.ok;
                });
              })
            ]);
          });
        });

        describe('#deleteTraces', function () {
          it('should lower the length of the data property', function () {
            var oldLength = hardcodedPlot.data.length;

            return hardcodedPlot.deleteTraces(0).then(function (polymerPlot) {
              expect(polymerPlot.data.length).to.equal(oldLength - 1);
            });
          });

          it('should delete the trace from the data property', function () {
            var deletedTrace = hardcodedPlot.data[0];

            return hardcodedPlot.deleteTraces(0).then(function (polymerPlot) {
              _(polymerPlot.data).forEach(function (trace) {
                expect(trace).to.not.deep.equal(deletedTrace);
              });
            });
          });

          it('should call low-level delete', function () {
            var deleteTraces = sandbox.spy(Plotly, 'deleteTraces');

            return hardcodedPlot.deleteTraces(0).then(function (polymerPlot) {
              expect(deleteTraces.withArgs(polymerPlot.$.plot, 0).calledOnce).to.be.ok;
            });
          });
        });

        describe('#moveTraces', function () {
          it('should not change the length of the data property', function () {
            var oldLength = hardcodedPlot.data.length;

            return hardcodedPlot.moveTraces(0).then(function (polymerPlot) {
              expect(polymerPlot.data.length).to.equal(oldLength);
            });
          });

          it('should update the data property', function () {
            var movedTraces = hardcodedPlot.data.slice(1);
            movedTraces.push(hardcodedPlot.data[0]);

            return hardcodedPlot.moveTraces(0).then(function (polymerPlot) {
              _(polymerPlot.data).forEach(function (trace, traceIndex) {
                expect(trace).to.deep.equal(movedTraces[traceIndex]);
              });
            });
          });

          it('should call low-level move', function () {
            var moveTraces = sandbox.spy(Plotly, 'moveTraces');

            return hardcodedPlot.moveTraces(0).then(function (polymerPlot) {
              expect(moveTraces.withArgs(polymerPlot.$.plot, 0).calledOnce).to.be.ok;
            });
          });
        });

        describe('#purge', function () {
          it('should clear the data property', function () {
            // Purge does not return a promise: it's synchronous
            return hardcodedPlot.purge().then(function (polymerPlot) {
              expect(polymerPlot.data).to.be.empty;
            });
          });
        });
      });
    </script>

  </body>
</html>
