<!doctype html>
<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport"
      content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

    <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
    <script src="../../web-component-tester/browser.js"></script>

    <!-- Step 1: import the element to test -->
    <link rel="import" href="../plotly-plot.html">
  </head>
  <body>
    <test-fixture id="plotly-plot-fixture-hardcoded">
      <template>
        <div id="wrapper">
          <plotly-plot id="hard-coded-plot"
            data='[
              {
                "x": [1, 2, 3, 4],
                "y": [10, 15, 13, 17],
                "mode": "markers",
                "type": "scatter"
              },
              {
                "x": [2, 3, 4, 5],
                "y": [16, 5, 11, 9],
                "mode": "lines",
                "type": "scatter"
              },
              {
                "x": [1, 2, 3, 4],
                "y": [12, 9, 15, 12],
                "mode": "lines+markers",
                "type": "scatter"
              }
            ]'
            layout='
              {
                "title":"Line and Scatter Plot",
                "height": 400,
                "width": 480
              }
            '
          >
          </plotly-plot>
        </div>
      </template>
    </test-fixture>

    <test-fixture id="plotly-plot-fixture-empty">
      <template>
        <plotly-plot id="empty-plot"></plotly-plot>
      </template>
    </test-fixture>

    <script>
      describe('<plotly-plot>', function () {
        var hardcodedPlot;
        var emptyPlot;
        var sandbox;
        var timeout = 100;

        // Convenience method for throwing errors when promises reject
        function fail(err) { throw new Error(err); }

        hardcodedPlot = fixture('plotly-plot-fixture-hardcoded')
          .querySelector('#hard-coded-plot');
        emptyPlot = fixture('plotly-plot-fixture-empty');

        beforeEach(function () {
          sandbox = sinon.sandbox.create();
        });

        afterEach(function () {
          sandbox.restore();
        });


        describe('#redraw', function () {
          beforeEach(function () {
            hardcodedPlot = fixture('plotly-plot-fixture-hardcoded')
              .querySelector('#hard-coded-plot');
            emptyPlot = fixture('plotly-plot-fixture-empty');
          });

          _.forEach([hardcodedPlot, emptyPlot], function (polymerPlot) {
            it('should not throw an error for ' + polymerPlot.id, function () {
              expect(polymerPlot.redraw.bind(hardcodedPlot)).to.not.throw();
            });
          });

          _.forEach([hardcodedPlot, emptyPlot], function (polymerPlot) {
            it('should update the data idempotently for ' + polymerPlot.id, function () {
              var values = [4, 11, 23, 14];
              polymerPlot.set('data.0.x', values);
              expect(polymerPlot.$.plot.data[0].x).to.deep.equal(values);
              polymerPlot.redraw()
              expect(polymerPlot.$.plot.data[0].x).to.deep.equal(values);
            });
          });

          _.forEach([hardcodedPlot, emptyPlot], function (polymerPlot) {
            it('should redraw on data update for ' + polymerPlot.id, function (done) {
              var values = [4, 11, 23, 14];
              var redraw = sandbox.spy(polymerPlot, 'redraw');

              polymerPlot.set('data.0.x', values);
              setTimeout(function () {
                expect(redraw.called).to.be.ok;
                done();
              }, timeout);
            });
          });

          _.forEach([hardcodedPlot, emptyPlot], function (polymerPlot) {
            it('should redraw on nested layout update for ' + polymerPlot.id, function (done) {
              var redraw = sandbox.spy(polymerPlot, 'redraw');
              polymerPlot.set('layout.title', 'New title');
              setTimeout(function () {
                expect(redraw.called).to.be.ok;
                done();
              }, timeout);
            });
          });

          _.forEach([hardcodedPlot, emptyPlot], function (polymerPlot) {
            it('should redraw on nested config update for ' + polymerPlot.id, function (done) {
              var redraw = sandbox.spy(polymerPlot, 'redraw');
              polymerPlot.set('config.showLink', false);
              setTimeout(function () {
                expect(redraw.called).to.be.ok;
                done();
              }, timeout);
            });
          });

          _.forEach([hardcodedPlot, emptyPlot], function (polymerPlot) {
            it('should not redraw in manual mode for ' + polymerPlot.id, function () {
              var redraw;
              var values = [4, 11, 23, 14];
              polymerPlot.manual = true;
              redraw = sandbox.spy(polymerPlot, 'redraw');

              return new Promise(function (resolve) {
                polymerPlot.set('data.0.x', values);

                setTimeout(function () {
                  expect(redraw.called).to.not.be.ok;
                  resolve();
                }, timeout);
              }).then(function () {
                return new Promise(function (resolve) {
                  polymerPlot.set('layout.title', 'New title');

                  setTimeout(function () {
                    expect(redraw.called).to.not.be.ok;
                    resolve();
                  }, timeout);
                });
              }).then(function () {
                return new Promise(function (resolve) {
                  polymerPlot.set('config.showLink', false);

                  setTimeout(function () {
                    expect(redraw.called).to.not.be.ok;
                    resolve();
                  }, timeout);
                });
              }).catch(fail);
            });
          });
        });

        describe('#restyle', function () {
          _.forEach([hardcodedPlot, emptyPlot], function (polymerPlot) {
            it('should update all traces by default for ' + polymerPlot.id, function () {
              return polymerPlot.restyle({mode: 'lines'})
                .then(function (resolvedPolymerPlot) {
                  _.forEach(resolvedPolymerPlot.data, function (trace) {
                    expect(trace.mode).to.equal('lines');
                  });
                }).catch(fail);
            });
          });

          it('should update specific traces by index', function () {
            return hardcodedPlot.restyle({mode: 'scatter'}, 0)
              .then(function (polymerPlot) {
                expect(polymerPlot.data[0].mode).to.equal('scatter');
                expect(polymerPlot.data[2].mode).to.not.equal('scatter');
              }).catch(fail);
          });

          it('should update specific traces by index list', function () {
            var traceIndices = [0, 2];

            return Promise.all([
              hardcodedPlot.restyle({mode: 'lines'}, traceIndices),
              hardcodedPlot.restyle({mode: 'markers'}, 1),
            ]).then(function (polymerPlots) {
              // Both elements of polymerPlots are the same element: hardcodedPlot

              _.forEach(traceIndices, function (traceIndex) {
                expect(polymerPlots[0].data[traceIndex].mode).to.equal('lines');
              });
              expect(polymerPlots[0].data[1].mode).to.equal('markers');
            }).catch(fail);
          });
        });

        describe('#relayout', function () {
          _.forEach([hardcodedPlot, emptyPlot], function (polymerPlot) {
            it('should update the layout property for ' + polymerPlot.id, function () {
              var newTitle = 'Some other new title';
              return polymerPlot.relayout({
                title: newTitle,
              }).then(function (resolvedPolymerPlot) {
                expect(resolvedPolymerPlot.layout.title).to.equal(newTitle);
              }).catch(fail);
            });
          });
        });

        describe('#resize', function () {
          beforeEach(function () {
            hardcodedPlot = fixture('plotly-plot-fixture-hardcoded')
              .querySelector('#hard-coded-plot');

            // Remove fixed size from layout properties
            hardcodedPlot.layout = {title: 'AutoResize Plot'};
          });

          it('should change the size when called', function () {
            expect(hardcodedPlot.layout.width).to.be.undefined;
            hardcodedPlot.parentNode.style.width = '1000px';
            expect(hardcodedPlot.parentNode.offsetWidth).to.equal(1000);

            expect(
              hardcodedPlot.$.plot
              .querySelector('div.svg-container').offsetWidth
            ).to.equal(480);

            return hardcodedPlot.resize().then(function () {
              expect(
                hardcodedPlot.$.plot
                .querySelector('div.svg-container').offsetWidth
              ).to.equal(1000);
            }).catch(fail);
          });

          it('should change the size when called via event', function (done) {
            expect(hardcodedPlot.layout.width).to.be.undefined;
            hardcodedPlot.parentNode.style.width = '1000px';
            expect(hardcodedPlot.parentNode.offsetWidth).to.equal(1000);

            expect(
              hardcodedPlot.$.plot
              .querySelector('div.svg-container').offsetWidth
            ).to.equal(480);

            hardcodedPlot.fire('iron-resize');

            // Call with setTimeout to put it in the event loop after the event
            // fires and its consequences are realized
            setTimeout(function () {
              expect(
                hardcodedPlot.$.plot
                .querySelector('div.svg-container').offsetWidth
              ).to.equal(1000);
              done();
            }, timeout);
          });

        });

        describe('#update', function () {
          _.forEach([hardcodedPlot, emptyPlot], function (polymerPlot) {
            it('should do nothing with a null update for ' + polymerPlot.id, function () {
              return polymerPlot.update().then(function (resolvedPolymerPlot) {
                expect(resolvedPolymerPlot).to.be.ok;
              }).catch(fail);
            });
          });

          _.forEach([hardcodedPlot, emptyPlot], function (polymerPlot) {
            it('should update the layout and data properties for ' + polymerPlot.id, function () {
              var newTitle = 'Some other new title';
              return polymerPlot.update({
                mode: 'lines',
              }, {
                title: newTitle,
              }).then(function (resolvedPolymerPlot) {
                // Layout update
                expect(resolvedPolymerPlot.layout.title).to.equal(newTitle);

                // Trace style update
                _.forEach(resolvedPolymerPlot.data, function (trace) {
                  expect(trace.mode).to.equal('lines');
                });
              }).catch(fail);
            });
          });
        });

        describe('#addTraces', function () {
          var newTrace;

          beforeEach(function () {
            newTrace = {
              x: [1, 2, 3, 4],
              y: [22, 9, 5, 11],
              mode: 'lines+markers',
              type: 'scatter',
            };
          });

          _.forEach([hardcodedPlot, emptyPlot], function (polymerPlot) {
            it('should add individual traces to the end by default for ' + polymerPlot.id, function () {
              return polymerPlot.addTraces(newTrace).then(function (resolvedPolymerPlot) {
                var data = resolvedPolymerPlot.data;
                expect(data[data.length - 1]).to.contain(newTrace);
              }).catch(fail);
            });
          });

          _.forEach([hardcodedPlot, emptyPlot], function (polymerPlot) {
            it('should add individual traces by index for ' + polymerPlot.id, function () {
              var oldHeadTrace = polymerPlot.data[0];
              return polymerPlot.addTraces(newTrace, 0).then(function (resolvedPolymerPlot) {
                var data = resolvedPolymerPlot.data;
                expect(data[0]).to.contain(newTrace);
                expect(data[1]).to.deep.equal(oldHeadTrace);
              }).catch(fail);
            });
          });

          _.forEach([hardcodedPlot, emptyPlot], function (polymerPlot) {
            it('should add lists of traces by index for ' + polymerPlot.id, function () {
              var addTraceIndices = [0, 1];
              var newTraces = [newTrace, newTrace];

              return polymerPlot.addTraces(newTraces, addTraceIndices).then(function (resolvedPolymerPlot) {
                _.forEach(addTraceIndices, function (traceIndex, iterationIndex) {
                  expect(resolvedPolymerPlot.data[traceIndex]).to.contain(newTraces[iterationIndex]);
                });
              }).catch(fail);
            });
          });
        });

        describe('#deleteTraces', function () {
          it('should lower the length of the data property', function () {
            var oldLength = hardcodedPlot.data.length;

            return hardcodedPlot.deleteTraces(0).then(function (polymerPlot) {
              expect(polymerPlot.data.length).to.equal(oldLength - 1);
            }).catch(fail);
          });

          it('should delete the trace from the data property', function () {
            var deletedTrace = hardcodedPlot.data[0];

            return hardcodedPlot.deleteTraces(0).then(function (polymerPlot) {
              _.forEach(polymerPlot.data, function (trace) {
                expect(trace).to.not.deep.equal(deletedTrace);
              });
            }).catch(fail);
          });

          it('should call low-level delete', function () {
            var deleteTraces = sandbox.spy(Plotly, 'deleteTraces');

            return hardcodedPlot.deleteTraces(0).then(function (polymerPlot) {
              expect(deleteTraces.withArgs(polymerPlot.$.plot, 0).calledOnce).to.be.ok;
            }).catch(fail);
          });
        });

        describe('#moveTraces', function () {
          beforeEach(function () {
            hardcodedPlot = fixture('plotly-plot-fixture-hardcoded')
              .querySelector('#hard-coded-plot');
          });

          it('should not change the length of the data property', function () {
            var oldLength = hardcodedPlot.data.length;

            return hardcodedPlot.moveTraces(0).then(function (polymerPlot) {
              expect(polymerPlot.data.length).to.equal(oldLength);
            }).catch(fail);
          });

          it('should update the data property', function () {
            var movedTraces = hardcodedPlot.data.slice(1);
            movedTraces.push(hardcodedPlot.data[0]);

            return hardcodedPlot.moveTraces(0).then(function (polymerPlot) {
              _.forEach(polymerPlot.data, function (trace, traceIndex) {
                expect(trace).to.deep.equal(movedTraces[traceIndex]);
              });
            }).catch(fail);
          });

          it('should call low-level move', function () {
            var moveTraces = sandbox.spy(Plotly, 'moveTraces');

            return hardcodedPlot.moveTraces(0).then(function (polymerPlot) {
              expect(moveTraces.withArgs(polymerPlot.$.plot, 0).calledOnce).to.be.ok;
            }).catch(fail);
          });
        });

        describe('#purge', function () {
          it('should clear the data property', function () {
            return hardcodedPlot.purge().then(function (polymerPlot) {
              expect(polymerPlot.data).to.be.empty;
            }).catch(fail);
          });
        });
      });
    </script>

  </body>
</html>
