<!doctype html>
<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

    <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
    <script src="../../web-component-tester/browser.js"></script>

    <!-- Step 1: import the element to test -->
    <link rel="import" href="../plotly-plot.html">
  </head>
  <body>
    <test-fixture id="plotly-plot-fixture-hardcoded">
      <template>
        <plotly-plot id="hard-coded-plot"
          data='[
            {
              "x": [1, 2, 3, 4],
              "y": [10, 15, 13, 17],
              "mode": "markers",
              "type": "scatter"
            },
            {
              "x": [2, 3, 4, 5],
              "y": [16, 5, 11, 9],
              "mode": "lines",
              "type": "scatter"
            },
            {
              "x": [1, 2, 3, 4],
              "y": [12, 9, 15, 12],
              "mode": "lines+markers",
              "type": "scatter"
            }
          ]'
          layout='
            {
              "title":"Line and Scatter Plot",
              "height": 400,
              "width": 480
            }
          '
        >
        </plotly-plot>
      </template>
    </test-fixture>

    <test-fixture id="plotly-plot-fixture-empty">
      <template>
        <plotly-plot id="empty-plot"></plotly-plot>
      </template>
    </test-fixture>

    <script>
      describe('<plotly-plot>', function () {
        var hardcodedPlot;
        var emptyPlot;
        var sandbox;

        beforeEach(function () {
          hardcodedPlot = fixture('plotly-plot-fixture-hardcoded');
          emptyPlot = fixture('plotly-plot-fixture-empty');
          sandbox = sinon.sandbox.create();
        });

        afterEach(function () {
          sandbox.restore();
        });


        describe('#redraw', function () {
          it('should not throw an error', function () {
            _([hardcodedPlot, emptyPlot]).each(function (polymerPlot) {
              expect(polymerPlot.redraw.bind(hardcodedPlot)).to.not.throw();
            });
          });

          it('should update the data idempotently', function () {
            _([hardcodedPlot, emptyPlot]).each(function (polymerPlot) {
              var values = [4, 11, 23, 14];
              polymerPlot.set('data.0.x', values);
              expect(polymerPlot.$.plot.data[0].x).to.deep.equal(values);
              polymerPlot.redraw()
              expect(polymerPlot.$.plot.data[0].x).to.deep.equal(values);
            });
          });

          it('should redraw on data update', function () {
            _([hardcodedPlot, emptyPlot]).each(function (polymerPlot) {
              var values = [4, 11, 23, 14];
              sandbox.stub(polymerPlot, 'redraw');
              polymerPlot.set('data.0.x', values);
              expect(polymerPlot.redraw.called).to.be.ok;
            });
          });

          it('should redraw on nested layout update', function () {
            _([hardcodedPlot, emptyPlot]).each(function (polymerPlot) {
              sandbox.stub(polymerPlot, 'redraw');
              polymerPlot.set('layout.title', 'New title');
              expect(polymerPlot.redraw.called).to.be.ok;
            });
          });

          it('should redraw on nested config update', function () {
            _([hardcodedPlot, emptyPlot]).each(function (polymerPlot) {
              sandbox.stub(polymerPlot, 'redraw');
              polymerPlot.set('config.showLink', false);
              expect(polymerPlot.redraw.called).to.be.ok;
            });
          });
        });

        describe('#restyle', function () {
          it('should update all traces by default', function () {
            _([hardcodedPlot, emptyPlot]).each(function (polymerPlot) {
              polymerPlot.restyle({mode: 'lines'});

              _(polymerPlot.data).forEach(function (trace) {
                expect(trace.mode).to.equal('lines');
              });

            });
          });

          it('should update specific traces by index', function () {
            hardcodedPlot.restyle({mode: 'lines'}, 0);
            expect(hardcodedPlot.data[0].mode).to.equal('lines');
            expect(hardcodedPlot.data[2].mode).to.not.equal('lines');
          });

          it('should update specific traces by index list', function () {
            var traceIndices = [0, 2];

            hardcodedPlot.restyle({mode: 'lines'}, traceIndices);
            hardcodedPlot.restyle({mode: 'markers'}, 1);

            _(traceIndices).forEach(function (traceIndex) {
              expect(hardcodedPlot.data[traceIndex].mode).to.equal('lines');
            });
            expect(hardcodedPlot.data[1].mode).to.equal('markers');
          });
        });

        describe('#relayout', function () {
          it('should update the layout property', function () {
            var newTitle = 'Some other new title';
            _([hardcodedPlot, emptyPlot]).each(function (polymerPlot) {
              polymerPlot.relayout({title: newTitle});
              expect(polymerPlot.layout.title).to.equal(newTitle);
            });
          });
        });

        describe('#addTraces', function () {
          var newTrace = {
            x: [1, 2, 3, 4],
            y: [22, 9, 5, 11],
            mode: 'lines+markers',
            type: 'scatter',
          };

          it('should add individual traces to the end by default', function () {
            _([hardcodedPlot, emptyPlot]).each(function (polymerPlot) {
              var data = polymerPlot.data;
              polymerPlot.addTraces(newTrace);
              expect(data[data.length - 1]).to.deep.equal(newTrace);
            });
          });

          it('should add individual traces by index', function () {
            _([hardcodedPlot, emptyPlot]).each(function (polymerPlot) {
              var data = polymerPlot.data;
              var oldHeadTrace = data[0];

              polymerPlot.addTraces(newTrace, 0);
              expect(data[0]).to.deep.equal(newTrace);
              expect(data[1]).to.deep.equal(oldHeadTrace);
            });
          });

          it('should add lists of traces by index', function () {
            _([hardcodedPlot, emptyPlot]).each(function (polymerPlot) {
              var addTraceIndices = [0, 1];
              var newTraces = [newTrace, newTrace];

              polymerPlot.addTraces(newTraces, addTraceIndices);
              _(addTraceIndices).forEach(function (traceIndex, iterationIndex) {
                expect(plotlyPlot.data[traceIndex]).to.deep.equal(newTraces[iterationIndex]);
              });
            });
          });

          it('should redraw', function () {
            _([hardcodedPlot, emptyPlot]).each(function (polymerPlot) {
              sandbox.stub(polymerPlot, 'redraw');
              polymerPlot.addTraces(newTrace);
              expect(polymerPlot.redraw.called).to.be.ok;
            });
          });
        });

        describe('#deleteTraces', function () {
          it('should lower the length of the data property', function () {
            var oldLength = hardcodedPlot.data.length;
            hardcodedPlot.deleteTraces(0);
            expect(hardcodedPlot.data.length).to.equal(oldLength - 1);
          });

          it('should delete the trace from the data property', function () {
            var deletedTrace = hardcodedPlot.data[0];
            hardcodedPlot.deleteTraces(0);
            _(hardcodedPlot.data).forEach(function (trace) {
              expect(trace).to.not.deep.equal(deletedTrace);
            });
          });

          it('should not call redraw', function () {
            sandbox.stub(hardcodedPlot, 'redraw');
            hardcodedPlot.deleteTraces(0);
            expect(hardcodedPlot.redraw.called).to.not.be.ok;
          });
        });

        describe('#moveTraces', function () {
          it('should not change the length of the data property', function () {
            var oldLength = hardcodedPlot.data.length;
            hardcodedPlot.moveTraces(0);
            expect(hardcodedPlot.data.length).to.equal(oldLength);
          });

          it('should update the data property', function () {
            var movedTraces = hardcodedPlot.data.slice(1);
            movedTraces.push(hardcodedPlot.data[0]);

            hardcodedPlot.moveTraces(0);

            _(hardcodedPlot.data).forEach(function (trace, traceIndex) {
              expect(trace).to.deep.equal(movedTraces[traceIndex]);
            });
          });

          it('should call redraw', function () {
            sandbox.stub(hardcodedPlot, 'redraw');
            hardcodedPlot.moveTraces(0);
            expect(hardcodedPlot.redraw.called).to.be.ok;
          });
        });

      });
    </script>

  </body>
</html>
