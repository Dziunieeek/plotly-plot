<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="plotly-import.html">

<!--
Polymer element for the plotly.js library

Example: a hard-coded plot

```html
<plotly-plot data='[{"x": [1, 2, 3], "y": [4, 11, 23]}]'>
</plotly-plot>
```

Example: a dynamically-set plot

```html
<plotly-plot id="the-plot"></plotly-plot>
<script>
   var plotElement = document.getElementById('the-plot');
   plotElement.set('data.0', {x: [1, 2, 3], y: [19, 3, 11]});
</script>
```

If you are changing the parameters dynamically and want your changes reflected
immediately, make sure to use `.set` or the plot will not update. Conversely,
change several parameters, and then call `.redraw`.

See the [plotly.js docs](https://plot.ly/javascript/reference/) for a full explanation
of the `data`, `layout` and `config` properties.

### NOTE: The plotly.js library is incompatible with shadow DOM

Polymer elements, and web components in general, depend on being able to "hide"
their inner DOM from the rest of the page. This is accomplished through a
set of functionality known as the "shadow DOM."

Polymer has two kinds of shadow DOM implementations: native shadow DOM, and a
shim called "shady DOM." Native shadow DOM is newer and yields improved
performance, but it has incomplete support in browsers outside the newest Chrome
and can often cause problems with existing code. For this reason, shady DOM is
still the default implementation in Polymer 1.x.

Unfortunately, native shadow DOM is currently incompatible with plotly.js. The
icon toolbar layout code in the plotly.js library fails for all plotly plots
rendered inside a shadow DOM, whether by Polymer or any other means. The
element cannot tell that the library code has misrendered. It acts as if it
rendered correctly and responds to JavaScript normally.

This is a library-level issue between plotly.js and the DOM. It does not have
to do with this element itself, and `<plotly-plot>` can't do anything about it
until either plotly.js or the shadow DOM code change to accommodate one another.

In the mean time, if you're using `<plotly-plot>`, make sure you
_do not have `Polymer.dom = 'shadow'` in the global Polymer settings of your
project_.

@demo demo/index.html
-->

<dom-module id="plotly-plot">
  <template>
    <div id="plot" data=[[data]] layout=[[layout]] config=[[config]]>
      <content></content>
    </div>
  </template>

  <script>
    Polymer({
      is: 'plotly-plot',

      properties: {
        /**
         * The data and parameters of each of the traces to be plotted. An
         * array of nested object that significantly depends on the plot type,
         * etc.
         *
         * @type {Array<Object>}
         * @default [{x: [], y: []}]
         *
         * @see the {@link https://plot.ly/javascript/reference/|plotly.js docs}
         */
        data: {
          type: Array,
          reflectToAttribute: true,
          notify: true,
          observer: '_autoRedraw',
          value: function () { return [{x: [], y: []}]; },
        },

        /**
         * Settings for the layout of the plot as  a whole:
         * width, height, title, etc.
         *
         * @type {Object}
         * @default {}
         *
         * @see the {@link https://plot.ly/javascript/reference/|plotly.js docs}
         */
        layout: {
          type: Object,
          reflectToAttribute: true,
          notify: true,
          observer: '_autoRelayout',
          value: function () { return {}; },
        },

        /**
         * Top-level configurations for features in the library: whether or
         * not to show the toolbar, plot.ly icon, whether or not to make the
         * plot static, etc.
         *
         * @type {Object}
         * @default {}
         *
         * @see the {@link https://plot.ly/javascript/reference/|plotly.js docs}
         */
        config: {
          type: Object,
          reflectToAttribute: true,
          notify: true,
          observer: '_autoRedraw',
          value: function () { return {}; },
        },

        /**
         * If true, manually update the plot instead of having it automatically
         * redraw itself on property changes (the default).
         *
         * @type {boolean}
         * @default false
         */
        manual: {
          type: Boolean,
          reflectToAttribute: true,
          notify: true,
          value: false,
        },

        /**
         * How often to allow automatic update events to fire. At most one such
         * event will happen every this number of milliseconds.
         *
         * @type {number}
         * @default 30
         */
        debounceInterval: {
          type: Number,
          value: 30,
        },
      },

      observers: [
        // Redraw the plot after any of the nested data in the properties change
        '_autoRedraw(data.*)',
        '_autoRedraw(layout.*)',
        '_autoRedraw(config.*)',
      ],

      behaviors: [
        // Resize the plot dynamically
        Polymer.IronResizableBehavior,
      ],

      listeners: {
        // Listen for the `iron-resize` event to implement fluid resizing.
        'iron-resize': '_onIronResize',
      },


      // Manage life cycle events

      /**
       * When the element is attached, create the plot and bind the Polymer
       * wrapper events to the plotly custom events.
       *
       * @return {Promise<Polymer.Base>}
       *  a Promise for the asynchronous plot creation that resolves to the
       *  Polymer element.
       */
      attached: function () {
        var self = this;
        // Fire Polymer events in accordance with the plotly.js ones as well.
        // These event handlers need to be bound to variables because of
        // event binding and unbinding upon attach/detach/reattach

        /**
         * Custom plotly-specific click event for tracking clicks on the chart.
         *
         * @event plotly-click
         * @see the {@link https://plot.ly/javascript/plotlyjs-events/|events reference}
         */
        self._onPlotlyClick = function (data) {
          return self.fire('plotly-click', {data: data});
        };

        /**
         * Custom plotly-specific event for tracking hovers on the chart.
         * Fires before the hover happens.
         *
         * @event plotly-beforehover
         * @see the {@link https://plot.ly/javascript/hover-events/|hover events tutorial}
         */
        self._onPlotlyBeforehover = function (data) {
          return self.fire('plotly-beforehover', {data: data});
        };

        /**
         * Custom plotly-specific event for tracking hovers on the chart.
         * Fires during the hover.
         *
         * @event plotly-hover
         * @see the {@link https://plot.ly/javascript/hover-events/|hover events tutorial}
         */
        self._onPlotlyHover = function (data) {
          return self.fire('plotly-hover', {data: data});
        };

        /**
         * Custom plotly-specific event for tracking hovers on the chart.
         * Fires when the hover ends.
         *
         * @event plotly-unhover
         * @see the {@link https://plot.ly/javascript/hover-events/|hover events tutorial}
         */
        self._onPlotlyUnhover = function (data) {
          return self.fire('plotly-unhover', {data: data});
        };

        return Plotly.newPlot(
          self.$.plot, self.data, self.layout, self.config
        ).then(function (plotDiv) {
          // Attach the polymer events to the plotly events.
          plotDiv.on('plotly_click', self._onPlotlyClick);
          plotDiv.on('plotly_beforehover', self._onPlotlyBeforehover);
          plotDiv.on('plotly_hover', self._onPlotlyHover);
          plotDiv.on('plotly_unhover', self._onPlotlyUnhover);

          return self;
        });
      },

      /**
       * When the element is detached, remove the attached Polymer events.
       */
      detached: function () {
        // Protect detaching listeners in an if statement, because
        // `removeListener` is plotly.js functionality, which is removed
        // if .purge is called before the element is detached.
        if (typeof this.$.plot.removeListener === 'function') {
          this.$.plot.removeListener('plotly_click', this._onPlotlyClick);
          this.$.plot.removeListener('plotly_beforehover', this._onPlotlyBeforehover);
          this.$.plot.removeListener('plotly_hover', this._onPlotlyHover);
          this.$.plot.removeListener('plotly_unhover', this._onPlotlyUnhover);
        }

        return;
      },


      // Manage other events

      /**
       * Resize the plot when the containing element is resized.
       *
       * @return {Promise<Polymer.Base>}
       *  a Promise for the resize action that resolves to the
       *  Polymer element.
       *
       * @see the {@link https://plot.ly/javascript/responsive-fluid-layout/|plotly.js fluid layout reference}
       */
      _onIronResize: function () {
        return this.resize();
      },


      // Generic implementation of any Plotly function

      /**
       * Return the value of a path on the Plotly object, or undefined if no
       * such path exists.
       *
       * Amounts to a safe way to call `eval('Plotly.' + path)`.
       *
       * @param {string=} path the path to find
       *
       * @return {*} Whatever is located at Plotly.`path` */
      getPlotly: function (path) {
        if (typeof path === 'undefined') {
          return Plotly;
        } else if (typeof path !== 'string') {
          throw new TypeError('Must pass string');
        } else {
          return this.get(path, Plotly);
        }
      },

      /**
       * Call a function in Plotly with the plot div as the first parameter.
       * This method should _not_ be used to call functions like `redraw` or
       * `relayout`, for which methods already exist. This is instead useful for
       * a convenient way to access low-level or "undocumented," but supported
       * functionality, such as the undo/redo queue. There are many functions
       * implemented in the Plotly.js API in completely ready-to-use and stable
       * ways, that are just not documented in the function reference yet.
       *
       * Caveat emptor. If you shoot yourself in the foot, consider yourself
       * warned. This method cannot be robust enough to account for everything
       * the plotly.js source exposes, and calling functions that are too
       * low-level without doing the appropriate surrounding work is a sure-fire
       * way to get in trouble.
       *
       * @example
       * var pplot = document.querySelector('plotly-plot');
       * // string API
       * pplot.call('Queue.undo')
       * // function API
       * pplot.call(Plotly.Queue.undo)
       * // either way amounts to basically doing the following:
       * Plotly.queue.undo(pplot.$.plot)
       *
       * @param {!string|function} func
       *  the path to the function to call, or the function itself
       * @param {*...} args
       *  arguments to pass to the method, if any
       *
       * @return {*}
       *  if the function returns a promise, update the element properties
       *  (data, layout, config) from the plot, in case they've changed after
       *  the promise resolves. If the promise resolves to the plot div, make
       *  that promise resolve to the element instead. Otherwise, just return
       *  whatever the plot resolves to.
       *
       * @see the {@link https://github.com/plotly/plotly.js/blob/master/src/|plotly.js source}
       */
      call: function (func) {
        var self = this;
        var requestedFunc;
        var args;
        var returnValue;

        // Check the sanity of the passed-in argument
        if (!func) {
          throw new ReferenceError('Must pass in a non-empty function name or path');
        }

        if (typeof func === 'string') {
          requestedFunc = self.getPlotly(func);
        } else if (typeof func === 'function') {
          requestedFunc = func;
        } else {
          throw new TypeError('Must pass a function or a path to one inside Plotly namespace');
        }

        if (typeof requestedFunc === 'undefined') {
          throw new ReferenceError('No function with the path "' + func + '" found');
        } else if (typeof requestedFunc !== 'function') {
          throw new TypeError('The path "' + func + '" does not resolve to a function');
        }

        if (requestedFunc.length < 1) {
          throw new TypeError('The function "' + func + '" does not take a plot div argument');
        }

        // If we've gotten here, we can be confident that requestedFunc is a
        // valid function that takes at least one parameter.

        // Pull everything after the first argument into an array for an
        // .apply call, and prepend the plot div to it
        args = Array.prototype.slice.call(arguments, 1);
        args.unshift(self.$.plot);

        // Call the function and store its return value
        returnValue = requestedFunc.apply(self.$.plot, args);

        // Special promise-handling logic which we can do safely
        if (returnValue && typeof returnValue.then === 'function') {
          return returnValue.then(function (resolvedValue) {
            // Upddate the element properties to reflect any changes done to
            // the plot div by requestedFunc.
            self._safeUpdateProps(function () {
              self.data = self.$.plot.data;
              self.layout = self.$.plot.layout;
              self.config = self.$.plot.config;
            });

            // Like our other methods, if requestedFunc resolves to the plot
            // div, resolve to the element itself instead.
            if (resolvedValue === self.$.plot) {
              return self;
            } else {
              return resolvedValue;
            }
          });
        } else {
          return (returnValue === self.$.plot ? self : returnValue);
        }
      },


      // Update the plot to reflect new data

      /**
       * Redraw the plot using the current state of the widget's properties.
       *
       * This should happen automatically if you use `.set`, but if you want to
       * do a lot of manipulation in multiple steps and then redraw at the end,
       * call this method.
       *
       * @return {Promise<Polymer.Base>}
       *  a Promise for the asynchronous plot update that resolves to the
       *  Polymer element.
       *
       * @see the {@link https://plot.ly/javascript/plotlyjs-function-reference/|plotly.js function reference}
       */
      redraw: function () {
        var self = this;

        // XXX For some reason, this class gets removed and plotly.js complains
        self.toggleClass('js-plotly-plot', true, self.$.plot);

        // Set the plot data, layout, and config state to reflect the current
        // state of the polymer properties
        self.$.plot.data = self.data;
        self.$.plot.layout = self.layout;
        self.$.plot.config = self.config;

        return Plotly.redraw(self.$.plot).then(function () {
          // Remove any tasks waiting to go; prevent any further debounced
          // redraws
          self.cancelDebouncer('autoRedraw');

          return self;
        });
      },

      /**
       * Automatically redraw the plot on data updates, if not manual.
       * Debounces the .redraw call.
       */
      _autoRedraw: function () {
        var self = this;

        if (typeof self.manual !== 'undefined' && !self.manual) {
          // Limit the frequency of redraw tasks by putting them in a
          // debounce queue
          self.debounce(
            'autoRedraw',
            function () { return self.redraw(); },
            self.debounceInterval
          );
        }

        return;
      },

      /**
       * Update the properties of the object object without triggering any
       * automatic actions they might be bound to, by turning on the 'manual'
       * flag temporarily
       *
       * @param {function (Polymer.Base, boolean, boolean): Promise<*>|<*>} updateAction
       *  the action to take; if asynchronous, should return a Promise. Otherwise,
       *  a typical value, or void, is fine. The function is passed the element,
       *  followed by the current and former states of the manual flag.
       *
       * @return {Promise<Polymer.Base>}
       *  a Promise that resolves to the element when the manual flag has been
       *  returned to its original value
       */
      _safeUpdateProps: function (updateAction) {
        var self = this;
        var oldManual;

        return new Promise(function (resolve, reject) {
          oldManual = self.manual;
          self.manual = true;
          resolve();
        }).then(function () {
          return updateAction(self, self.manual, oldManual);
        }).then(function () {
          self.manual = oldManual;
          return self;
        });
      },


      /**
       * Restyle the plot with updates to all (or a specified subset of) the
       * traces. Will update the plot's `data` property with the effective
       * resulting changes.
       *
       * @param {Object<string,*|Array>} style
       *  an object whose keys are normal trace keys, and whose values are
       *  either regular keys, or array versions of the normal trace object
       *  values: one value in the array will be applied to each of the traces
       *  in the `traceIndices` argument.
       * @param {number|Array<number>} traceIndices
       *  a single index, or an array of indices of traces (the elements of
       *  `.data`) on which to apply the styles
       *
       * @return {Promise<Polymer.Base>}
       *  a Promise for the asynchronous plot update that resolves to the
       *  Polymer element.
       *
       * @see the {@link https://plot.ly/javascript/plotlyjs-function-reference/|plotly.js function reference}
       */
      restyle: function (style, traceIndices) {
        var self = this;

        return Plotly.restyle(self.$.plot, style, traceIndices)
          .then(function (plotDiv) {
            // Update the Polymer properties to reflect the updated data without
            // triggering any new relayout calls.
            return self._safeUpdateProps(function () {
              self.data = plotDiv.data;
            });
          });
      },

      /**
       * Update the plot layout. Will update the plot's `layout` property
       * with the effective resulting changes.
       *
       * @param {Object} layoutUpdate
       *  the data to change in the `layout` property
       *
       * @return {Promise<Polymer.Base>}
       *  a Promise for the asynchronous plot update that resolves to the
       *  Polymer element.
       *
       * @see the {@link https://plot.ly/javascript/plotlyjs-function-reference/|plotly.js function reference}
       */
      relayout: function (layoutUpdate) {
        var self = this;

        return Plotly.relayout(self.$.plot, layoutUpdate)
          .then(function (plotDiv) {
            // Remove any debounced relayout tasks waiting to go;
            // prevent any further relayouts
            self.cancelDebouncer('autoRelayout');

            // Update the Polymer properties to reflect the updated data without
            // triggering any new relayout calls.
            return self._safeUpdateProps(function () {
              self.layout = plotDiv.layout;
            });
          });
      },

      /**
       * Automatically redraw the plot on layout updates, unless `manual` is
       * set. Debounces the `.relayout` call.
       *
       * @param {Object} layoutUpdate
       *  the data to change in the `layout` property
       */
      _autoRelayout: function (layoutUpdate) {
        var self = this;

        if (typeof self.manual !== 'undefined' && !self.manual) {
          // Limit the frequency of relayout tasks by putting them in a
          // debounce queue
          self.debounce(
            'autoRelayout',
            function () { self.relayout(layoutUpdate); },
            self.debounceInterval
          );
        }

        return;
      },

      /**
       * Resize the plot to fit in its container.
       *
       * @return {Promise<Polymer.Base>}
       *  a Promise for the resize action that resolves to the
       *  Polymer element.
       *
       * @see the {@link https://plot.ly/javascript/responsive-fluid-layout/|plotly.js fluid layout reference}
       */
      resize: function () {
        var self = this;

        return Plotly.Plots.resize(self.$.plot).then(function () {
          return self;
        });
      },

      /**
       * Update the data and layout simultaneously by passing in parameters
       *
       * @param {Object} traceUpdate
       *  attribute object `{astr1: val1, astr2: val2 ...}`
       *  corresponding to updates in the plot's traces
       * @param {Object=} layoutUpdate
       *  attribute object `{astr1: val1, astr2: val2 ...}`
       *  corresponding to updates in the plot's layout
       * @param {number|Array<number>=} traces
       *  integer or array of integers for the traces to alter (all if omitted)
       *
       * @return {Promise<Polymer.Base>}
       *  a Promise for the asynchronous plot update that resolves to the
       *  Polymer element.
       *
       * @see the {@link https://github.com/plotly/plotly.js/blob/master/src/plot_api/plot_api.js#L2148|plotly.js source}
       */
      update: function (traceUpdate, layoutUpdate, traces) {
        var self = this;

        return Plotly.update(self.$.plot, traceUpdate, layoutUpdate, traces)
          .then(function (plotDiv) {
            // Remove any debounced relayout tasks waiting to go;
            // prevent any further relayouts
            self.cancelDebouncer('autoRelayout');

            // Update the Polymer properties to reflect the updated data without
            // triggering any new relayout calls.
            return self._safeUpdateProps(function () {
              self.layout = plotDiv.layout;
              self.data = plotDiv.data;
            });
          });
      },

      // Manipulate traces

      /**
       * Add traces to the plot in the specified indices, if provided.
       *
       * @param {(Object|Array<Object>)} traces
       *  an individual trace, as an object of trace information, or an array
       *  of those traces
       * @param {(number|Array<number>)=} traceIndices
       *  an individual index or an array of indices specifying where to add
       *  the traces
       *
       * @return {Promise<Polymer.Base>}
       *  a Promise for the asynchronous plot update that resolves to the
       *  Polymer element.
       *
       * @see the {@link https://plot.ly/javascript/plotlyjs-function-reference/|plotly.js function reference}
       */
      addTraces: function (traces, traceIndices) {
        var self = this;

        return Plotly.addTraces(self.$.plot, traces, traceIndices)
          .then(function (plotDiv) {
            // Update the Polymer properties to reflect the updated data without
            // triggering any new relayout calls.
            return self._safeUpdateProps(function () {
              self.data = plotDiv.data;
            });
          });
      },

      /**
       * Delete the specified traces from the plot.
       *
       * @param {(number|Array<number>)=} traceIndices
       *  an individual index or an array of indices specifying which traces to
       *  delete
       *
       * @return {Promise<Polymer.Base>}
       *  a Promise for the asynchronous plot update that resolves to the
       *  Polymer element.

       * @see the {@link https://plot.ly/javascript/plotlyjs-function-reference/|plotly.js function reference}
       */
      deleteTraces: function (traceIndices) {
        var self = this;

        return Plotly.deleteTraces(self.$.plot, traceIndices)
          .then(function (plotDiv) {
            // Update the Polymer properties to reflect the updated data without
            // triggering any new relayout calls.
            return self._safeUpdateProps(function () {
              self.data = plotDiv.data;
            });
          });
      },

      /**
       * Move a specified set of traces from the plot to a newly specified set
       * of destination trace positions.
       *
       * @param {(number|Array<number>)} traceIndicesFrom
       *  an individual index or an array of indices specifying which traces to
       *  move
       * @param {(number|Array<number>)} traceIndicesTo
       *  an individual index or an array of indices specifying where the
       *  traces should move
       *
       * @return {Promise<Polymer.Base>}
       *  a Promise for the asynchronous plot update that resolves to the
       *  Polymer element.
       *
       * @see the {@link https://plot.ly/javascript/plotlyjs-function-reference/|plotly.js function reference}
       */
      moveTraces: function (traceIndicesFrom, traceIndicesTo) {
        var self = this;

        return Plotly.moveTraces(self.$.plot, traceIndicesFrom, traceIndicesTo)
          .then(function (plotDiv) {
            // Update the Polymer properties to reflect the updated data without
            // triggering any new relayout calls.
            return self._safeUpdateProps(function () {
              self.data = plotDiv.data;
            });
          });
      },

      /**
       * Clear all plots and snapshots.
       *
       * @return {Polymer.Base} the current element
       *
       * @return {Promise<Polymer.Base>}
       *  a Promise for the purge that resolves to the
       *  Polymer element.
       *
       * @see the {@link https://plot.ly/javascript/plotlyjs-function-reference/|plotly.js function reference}
       */
      purge: function () {
        var self = this;

        return Promise.resolve(
          Plotly.purge(self.$.plot)
        ).then(function () {
          // Safely clear all the properties
          return self._safeUpdateProps(function () {
            self.$.plot.data = [];
            self.data = [];

            self.$.plot.layout = {};
            self.layout = {};
          });
        });
      },

    });
  </script>
</dom-module>
